// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  seed     = "ts-node -r tsconfig-paths/register prisma/seed.ts"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum EnumAssistantArea {
  BRAND_EXPERT // Lily
  MARKETING_ASSISTANT // Zoe
  FINCANCE_ASSISTANT // Oscar
  UPSELL_ASSISTANT // Niko
}

enum EnumIndustrySector {
  AUTOMOTIVE
  CUSTOMER_SERVICE
  EDUCATION
  HEALTHCARE
  REAL_ESTATE
  OTHER
}

enum EnumIndustryOperationChannel {
  ONLINE
  PHYSICAL
  MIXED
}

enum FileStatus {
  PENDING
  UPLOADING
  UPLOADED
  COPYING
  PROCESSING
  ERASING
}

enum UserActivityType {
  AUTHENTICATION
  PROFILE_MANAGEMENT
  ROLE_MANAGEMENT
  SECURITY_SETTINGS
  COMPANY_ASSIGNMENT
  ACCOUNT_MANAGEMENT
}

enum UserActivityImpact {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum NotificationStatus {
  NOT_PROVIDED
  PENDING_TO_SEND
  SENT
  SEND_ERROR
}

enum PaymentOption {
  FINANCING
  CREDIT
  CASH
}

enum FileType {
  IMAGE
  VIDEO
  AUDIO
  DOCUMENT
  OTHER
}

enum BulkProcessingType {
  PRODUCT_CATALOG
  CLIENT_REMINDER
  // Add more types as needed
}

enum BulkProcessingStatus {
  PENDING
  PROCESSING
  CANCELLING
  COMPLETED
  FAILED
  CANCELLED
}

enum ReminderStatus {
  PENDING
  IN_PROGRESS
  FAILED
  DONE
}

enum ReminderQueueStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  STANDBY
}

enum ReminderNotificationOptOutType {
  REMINDERS
  MARKETING
}

enum NotificationMedium {
  WHATSAPP
}

enum ReminderFrequency {
  DAILY
  WEEKLY
  MONTHLY
  YEARLY
}

model CompanySchedules {
  id          String   @id @default(uuid())
  dayOfWeek   Int      // 0=Sunday, 1=Monday, ..., 6=Saturday
  startTime   DateTime // Solo hora y minutos
  endTime     DateTime // Solo hora y minutos
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  company     Company  @relation(fields: [companyId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  companyId   String

  @@unique([companyId, dayOfWeek])
}

model AIAssistant {
  id          String                    @id @default(uuid())
  name        String                    @unique
  area        EnumAssistantArea
  available   Boolean                   @default(false)
  description Json
  createdAt   DateTime                  @default(now())
  updatedAt   DateTime                  @updatedAt

  features    AIAssistantFeature[]
  assignments CompanyAIAssistant[]
}

model AIAssistantFeature {
  id             String         @id @default(uuid())
  aiAssistant    AIAssistant    @relation(fields: [aiAssistantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  aiAssistantId  String
  keyName        String
  title          Json
  description    Json
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  companyAIAssistantFeature CompanyAIAssistantFeature[]

  @@unique([keyName])
  @@index([aiAssistantId])
}

model CompanyAIAssistant {
  id             String                    @id @default(uuid())
  company        Company                   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  companyId      String
  aiAssistant    AIAssistant               @relation(fields: [aiAssistantId], references: [id], onDelete: Cascade)
  aiAssistantId  String
  enabled        Boolean                   @default(false)
  createdAt      DateTime                  @default(now())
  updatedAt      DateTime                  @updatedAt

  features       CompanyAIAssistantFeature[]

  @@unique([companyId, aiAssistantId])
  @@index([companyId])
  @@index([aiAssistantId])
}

model CompanyAIAssistantFeature {
  id                          String                 @id @default(uuid())
  assignment                  CompanyAIAssistant     @relation(fields: [assignmentId], references: [id], onDelete: Cascade)
  assignmentId                String
  aiAssistantFeature          AIAssistantFeature     @relation(fields: [featureId], references: [id], onDelete: Cascade)
  featureId                   String
  enabled                     Boolean                @default(false)
  createdAt                   DateTime               @default(now())
  updatedAt                   DateTime               @updatedAt

  @@unique([assignmentId, featureId])
  @@index([assignmentId])
  @@index([featureId])
}

// por implementar
model AvatarList {
  id          String   @id @default(uuid())
  imageUrl    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Sessions {
  id           String   @id @default(uuid())
  userId       String
  sessionToken String   @unique
  refreshToken String   @unique
  userAgent    String?
  ipAddress    String

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  
  @@index([userId])
}

model Country {
  id          String   @id @default(uuid())
  name        String   @unique
  imageUrl    String?
  phoneCode   String   @unique
  langCode    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  states        State[]

  userAddress UserAddress[]
}

model State {
  id          String   @id @default(uuid())
  name        String   @unique
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  country     Country  @relation(fields: [countryId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  countryId   String

  userAddress UserAddress[]
  
  @@index([countryId])
}

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  passwordHash  String
  firstName     String
  lastName      String
  secondLastName String?
  alias         String?   @unique
  isActive      Boolean   @default(true)
  isReactivable Boolean   @default(true) // false means user is banned and cannot be reactivated
  emailVerified Boolean   @default(false)
  otpEnabled    Boolean   @default(false)
  otpSecret     String?
  lastLoginAt   DateTime?
  companyId     String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  bannedUntil   DateTime?
  banReason     String?
  agentPhone    String?   // se usa para buscar a los agentes de ventas por su número de teléfono en la compañia (tenat-id)
  agentPhoneCountryCode String? @default("52") // código de país para agentPhone (ej: 52 para México)
  
  // Notification status tracking
  smsStatus     NotificationStatus @default(NOT_PROVIDED)
  emailStatus   NotificationStatus @default(NOT_PROVIDED)
  lastSmsError  String?
  lastEmailError String?

  company       Company?  @relation(fields: [companyId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  roles         UserRole[]
  otps          Otp[]
  refreshTokens RefreshToken[]
  passwordResets PasswordReset[]
  files         File[]
  profile       UserProfile?
  address       UserAddress?
  sessions      Sessions[]
  auditLogs     AuditLog[]
  activityLogs  UserActivityLog[]
  botTokensAsBot BotToken[] @relation("BotTokenUser")
  botTokensIssued BotToken[] @relation("BotTokenIssuer")
  botTokensRevoked BotToken[] @relation("BotTokenRevoker")
  storageConfig UserStorageConfig?
  aiPersonasCreated AIPersona[] @relation("AIPersonaCreator")
  aiPersonasUpdated AIPersona[] @relation("AIPersonaUpdater")
  companyAIPersonasAssigned CompanyAIPersona[]
  marketingCampaignsCreated MarketingCampaign[] @relation("MarketingCampaignCreatedBy")
  marketingCampaignsUpdated MarketingCampaign[] @relation("MarketingCampaignUpdatedBy")
  productMediaCreated ProductMedia[]
  productCatalogsCreated ProductCatalog[] @relation("ProductCatalogCreatedBy")
  bulkProcessingRequests BulkProcessingRequest[]
  productCatalogsUpdated ProductCatalog[] @relation("ProductCatalogUpdatedBy")
  clientReminderRequestedBy ClientReminder[] @relation("ClientReminderRequestedBy")
  clientReminderUpdatedBy ClientReminder[] @relation("ClientReminderUpdatedBy")
  clientReminderQueueCreatedBy ClientReminderQueue[] @relation("ClientReminderQueueCreatedBy")
  clientReminderQueueUpdatedBy ClientReminderQueue[] @relation("ClientReminderQueueUpdatedBy")
  
  @@index([companyId])
  @@unique([agentPhone, companyId])
}

model UserProfile {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId    String
  phone     String?
  phoneCountryCode String? @default("52") // código de país para phone (ej: 52 para México)
  avatarUrl String?
  bio       String?
  birthdate String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId])
}

model UserAddress {
  id              String    @id @default(uuid())

  country   Country? @relation(fields: [countryId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  countryId String?

  state     State?   @relation(fields: [stateId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  stateId   String?

  city            String?
  street          String?
  exteriorNumber  String?
  interiorNumber  String?
  postalCode      String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  user            User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId          String @unique
}

model Role {
  id                String   @id @default(uuid())
  name              String   @unique
  description       String
  hierarchyLevel    Int      @default(5) // 1=root, 2=admin, 3=manager, 4=sales_agent/host, 5=guest
  isDefault         Boolean  @default(false)
  isDefaultAppRole  Boolean  @default(false)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  users       UserRole[]
  permissions RolePermission[]
}

model Permission {
  id          String   @id @default(uuid())
  name        String   @unique
  description String
  resource    String
  action      String
  excludeRoles Json?   // Array of role names that cannot have this permission, or '*' for all roles, '**' for custom roles
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  roles       RolePermission[]
}

model UserRole {
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId    String
  role      Role     @relation(fields: [roleId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  roleId    String
  createdAt DateTime @default(now())

  @@id([userId, roleId])
}

model RolePermission {
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  roleId       String
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  permissionId String
  createdAt    DateTime   @default(now())

  @@id([roleId, permissionId])
}

model Otp {
  id         String    @id @default(uuid())
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId     String
  secret     String
  expiresAt  DateTime
  verifiedAt DateTime?
  createdAt  DateTime  @default(now())
}

model RefreshToken {
  id        String    @id @default(uuid())
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId    String
  token     String    @unique
  expiresAt DateTime
  revokedAt DateTime?
  createdAt DateTime  @default(now())
}

model EmailVerification {
  id         String    @id @default(uuid())
  email      String    
  code       String
  expiresAt  DateTime
  verifiedAt DateTime?
  createdAt  DateTime  @default(now())
  
  @@index([email])
}

model PasswordReset {
  id        String    @id @default(uuid())
  userId    String
  email     String    
  token     String    @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())
  
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  
  @@index([email])
  @@index([token])
}

model Company {
  id            String    @id @default(uuid())
  name          String    @unique
  description   String
  host          String    @unique
  isActive      Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  timezone      String? @default("America/Mexico_City")
  currency      String? @default("MXN")
  logoUrl       String?
  websiteUrl    String?
  privacyPolicyUrl String?
  language      String @default("es-MX")

  industrySector EnumIndustrySector @default(OTHER)
  industryOperationChannel EnumIndustryOperationChannel @default(MIXED)
  
  // AI Configuration JSON field
  configAI      Json? // JSON configuration for AI settings
  lastUpdated   DateTime? // AI configuration last updated timestamp
  
  // Parent company relationship (self-referential)
  parentCompanyId String?
  parentCompany   Company? @relation("CompanyHierarchy", fields: [parentCompanyId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  subsidiaries    Company[] @relation("CompanyHierarchy")
  
  address       Address?
  users         User[]
  assistants    CompanyAIAssistant[]
  schedules     CompanySchedules[]
  botTokens     BotToken[]
  aiPersonas      AIPersona[]
  companyAIPersonas CompanyAIPersona[]
  marketingCampaigns MarketingCampaign[]
  productCatalogs ProductCatalog[]
  bulkProcessingRequests BulkProcessingRequest[]
  
  @@index([parentCompanyId])
  clientReminder ClientReminder[]
  clientReminderQueue ClientReminderQueue[]
}

model Address {
  id              String    @id @default(uuid())
  country         String
  state           String
  city            String
  street          String
  exteriorNumber  String
  interiorNumber  String?
  postalCode      String
  companyId       String    @unique
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  googleMapsUrl   String?
  
  company         Company   @relation(fields: [companyId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

// Track password reset attempts for rate limiting (3 per day)
model PasswordResetAttempt {
  id        String   @id @default(uuid())
  email     String
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  
  @@index([email, createdAt])
  @@index([ipAddress, createdAt])
}

model File {
  id          String    @id @default(uuid())
  filename    String
  originalName String
  path        String    // Virtual folder path (e.g., "invoices/2025/aug")
  objectKey   String    // Full S3/MinIO object key (path + filename)
  mimeType    String
  size        Int       // Final size in bytes
  bucket      String
  userId      String?
  isPublic    Boolean   @default(false)
  status      FileStatus @default(PENDING)
  uploadId    String?   // S3 multipart uploadId (only during UPLOADING)
  etag        String?   // ETag of completed object
  targetApps  String[]  @default([]) // Target applications with specific size restrictions
  storageDriver String  @default("minio") // Storage driver used (minio, aws)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  user        User?     @relation(fields: [userId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  marketingCampaigns MarketingCampaign[]
  productMedia ProductMedia[]
  bulkProcessingRequests BulkProcessingRequest[]

  @@index([userId])
  @@index([status])
  @@index([userId, status])
  @@index([userId, bucket])
  @@index([path, bucket])
  @@index([path, bucket, storageDriver])
  @@index([storageDriver])
  @@index([userId, storageDriver])
  @@index([storageDriver, status])
  @@unique([bucket, objectKey, storageDriver])
}

model StorageTiers {
  id                    String   @id @default(uuid())
  name                  String   @unique // Tier name (e.g., "basic", "premium", "enterprise")
  level                 String   @unique // Tier level (e.g., "1", "2", "3")
  maxStorageBytes       BigInt   // Maximum storage in bytes (default 200MB = 209715200 bytes)
  maxSimultaneousFiles  Int      @default(10) // Maximum files per simultaneous upload
  isActive              Boolean  @default(true) // Whether this tier is currently available
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  // Relations
  userStorageConfigs    UserStorageConfig[]

  @@index([level])
  @@index([isActive])
}

model UserStorageConfig {
  id                    String   @id @default(uuid())
  userId                String   @unique
  storageTierId         String   // Reference to StorageTiers
  allowedFileConfig     Json     // JSON with file extensions and their corresponding mime types: {"jpg": ["image/jpeg"], "pdf": ["application/pdf"]}
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  // Relations
  user                  User         @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  storageTier           StorageTiers @relation(fields: [storageTierId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  @@index([userId])
  @@index([storageTierId])
}

model AuditLog {
  id        String   @id @default(uuid())
  level     String   // info, warn, error, debug, critical
  type      String   // auth, user, role, permission, company, system, api, database, security, exception, transaction
  action    String   // create, read, update, delete, login, logout, register, verify, reset, assign, revoke, access, error, exception, etc.
  message   String
  userId    String?
  metadata  Json     // Comprehensive metadata including request details, session info, etc.
  timestamp DateTime @default(now())
  context   String   // system, auth, security, api, exception, transaction, etc.
  
  user      User?    @relation(fields: [userId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  @@index([level, timestamp])
  @@index([type, timestamp])
  @@index([userId, timestamp])
  @@index([context, timestamp])
  @@index([timestamp])
  @@index([level, type])
  @@map("AuditLog")
}

model UserActivityLog {
  id            String              @id @default(uuid())
  userId        String
  activityType  UserActivityType
  action        String              // register, login, change-password, setup-2fa, assign-role, etc.
  description   String              // Human-readable description
  impact        UserActivityImpact
  version       String              @default("1.0.0") // Schema version for backwards compatibility
  ipAddress     String?
  userAgent     String?
  metadata      Json?               // Additional context data
  timestamp     DateTime            @default(now())
  
  user          User                @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([userId, timestamp])
  @@index([activityType, timestamp])
  @@index([impact, timestamp])
  @@index([timestamp])
  @@map("UserActivityLog")
}

model BotToken {
  id               String    @id @default(uuid())
  tokenId          String    @unique // JWT token identifier (UUID)
  sessionTokenId   String    @unique // Session token (jti) for validation
  botUserId        String    // BOT user ID
  botEmail         String    // BOT user email
  companyId        String?   // Company association (optional for global BOTs)
  issuedBy         String    // Root user who issued the token
  issuedAt         DateTime  @default(now())
  revokedAt        DateTime? // When token was revoked
  revokedBy        String?   // Who revoked the token
  isActive         Boolean   @default(true) // Active status
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  
  // Relations
  botUser     User      @relation("BotTokenUser", fields: [botUserId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  company     Company?  @relation(fields: [companyId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  issuer      User      @relation("BotTokenIssuer", fields: [issuedBy], references: [id], onDelete: Cascade, onUpdate: Cascade)
  revoker     User?     @relation("BotTokenRevoker", fields: [revokedBy], references: [id], onDelete: SetNull, onUpdate: Cascade)
  
  // Indexes for performance
  @@index([tokenId]) // Primary lookup
  @@index([botUserId, isActive]) // BOT user tokens
  @@index([companyId, isActive]) // Company tokens
  @@index([isActive, revokedAt]) // Active/revoked status
  @@index([issuedBy, issuedAt]) // Issued by user
}

model AIPersona {
  id           String    @id @default(uuid())
  name         String    // Max 10 chars - validated in DTO
  keyName      String    // Normalized name: lowercase, no accents, spaces to underscores
  tone         Json      // JSON object with language keys: {"es-MX": "Professional", "en-US": "Professional"}
  personality  Json      // JSON object with language keys: {"es-MX": "Analítico", "en-US": "Analytical"}
  objective    Json      // JSON object with language keys: {"es-MX": "Proporcionar soluciones", "en-US": "Provide solutions"}
  shortDetails Json      // JSON object with language keys: {"es-MX": "Descripción breve", "en-US": "Brief description"} - Max 75 chars per language
  isDefault    Boolean   @default(false)  // True for system-wide default personas (root only)
  companyId    String?   // NULL for default personas, populated for company-specific personas
  isActive     Boolean   @default(true)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  createdBy    String?
  updatedBy    String?

  // Relations
  company      Company?  @relation(fields: [companyId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  creator      User?     @relation("AIPersonaCreator", fields: [createdBy], references: [id], onDelete: SetNull, onUpdate: Cascade)
  updater      User?     @relation("AIPersonaUpdater", fields: [updatedBy], references: [id], onDelete: SetNull, onUpdate: Cascade)
  
  // Junction table for company assignments
  companyAssignments CompanyAIPersona[]

  // Unique constraints
  @@unique([keyName, companyId]) // keyName must be unique within company or within defaults
  @@index([isDefault])
  @@index([companyId])
  @@index([isActive])
  @@index([createdAt])
}

// Junction table: Each company can have only one active AI persona
model CompanyAIPersona {
  id           String    @id @default(uuid())
  companyId    String    @unique  // UNIQUE ensures only one AI persona per company
  aiPersonaId  String
  isActive     Boolean   @default(true)
  assignedAt   DateTime  @default(now())
  assignedBy   String?

  // Relations
  company      Company   @relation(fields: [companyId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  aiPersona    AIPersona @relation(fields: [aiPersonaId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  assignedUser User?     @relation(fields: [assignedBy], references: [id], onDelete: SetNull, onUpdate: Cascade)

  @@index([aiPersonaId])
  @@index([isActive])
}

model MarketingCampaign {
  id               String    @id @default(uuid())
  startDate        DateTime
  endDate          DateTime
  utmName          String    @unique @db.VarChar(255)
  referenceName    String    @db.VarChar(255)
  context          String    @db.Text
  enabled          Boolean   @default(false)
  metaId           String?   @db.VarChar(255)
  promotionPictureId String?
  companyId        String
  createdBy        String
  updatedBy        String
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  // Relations
  company          Company   @relation(fields: [companyId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  promotionPicture File?     @relation(fields: [promotionPictureId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  createdByUser    User      @relation("MarketingCampaignCreatedBy", fields: [createdBy], references: [id], onDelete: Restrict, onUpdate: Cascade)
  updatedByUser    User      @relation("MarketingCampaignUpdatedBy", fields: [updatedBy], references: [id], onDelete: Restrict, onUpdate: Cascade)

  @@index([companyId])
  @@index([enabled])
  @@index([startDate, endDate])
}

model ProductCatalog {
  id               String   @id // Custom ID (can be UUID, SKU, etc.)
  industry         String
  productService   String   // Product or Service name
  type             String
  subcategory      String
  listPrice        Decimal? @db.Decimal(10, 2)
  paymentOptions   PaymentOption[]
  description      String?  @db.Text
  companyId        String
  createdBy        String   // User who created the product
  updatedBy        String?  // User who last updated the product
  
  // NUEVO: Campos opcionales para carga masiva
  link             String?  // Link del producto (opcional)
  sourceFileName   String?  // Nombre del archivo del cual fue agregado este registro
  sourceRowNumber  Int?     // Número de fila del archivo de donde fue tomado el producto
  langCode         String?  // ISO / BCP47 langCode (ej: "es-MX", "en-US", "pt-BR")
  bulkRequestId    String?  // ID del bulk processing request para trazabilidad
  isVisible        Boolean  @default(true) // Indicates if the product is visible/active
  
  // Metadata JSON para URLs multimedia y otros datos
  metadata         Json?    // JSON object mapping media types to URLs (photo, video, pdf, etc.)
  
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  
  // Relations
  company          Company              @relation(fields: [companyId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  creator          User                 @relation("ProductCatalogCreatedBy", fields: [createdBy], references: [id], onDelete: Restrict, onUpdate: Cascade)
  updater          User?                @relation("ProductCatalogUpdatedBy", fields: [updatedBy], references: [id], onDelete: Restrict, onUpdate: Cascade)
  bulkRequest      BulkProcessingRequest? @relation(fields: [bulkRequestId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  media            ProductMedia[]
  
  @@unique([id, companyId]) // Ensure ID is unique per company
  @@index([companyId])
  @@index([industry])
  @@index([type])
  @@index([subcategory])
  @@index([bulkRequestId])
  @@index([isVisible])

  // === Columna de búsqueda FTS ===
  // Prisma no modela la expresión GENERATED; mantenemos el valor con trigger (ver migración 20250922121233_product_search_fns).
  search_vector Unsupported("tsvector")? @map("search_vector")

  // === Índices que Prisma mantiene ===
  // Filtros comunes (BTREE)
  @@index([companyId, isVisible], map: "idx_productcatalog_company_visible")
  @@index([companyId, createdAt],  map: "idx_productcatalog_company_createdat")

  // FTS (GIN sobre tsvector)
  @@index([search_vector], type: Gin, map: "idx_productcatalog_search_vector")

  // Fallbacks TRGM (GIN + gin_trgm_ops) para LIKE/ILIKE/typos
  @@index([productService(ops: raw("gin_trgm_ops"))], type: Gin, map: "idx_pc_trgm_productservice")
  @@index([type(ops: raw("gin_trgm_ops"))],           type: Gin, map: "idx_pc_trgm_type")
  @@index([subcategory(ops: raw("gin_trgm_ops"))],    type: Gin, map: "idx_pc_trgm_subcategory")
  @@index([industry(ops: raw("gin_trgm_ops"))],       type: Gin, map: "idx_pc_trgm_industry")
}

model ProductMedia {
  id          String   @id @default(uuid())
  fileId      String
  fileType    FileType
  fav         Boolean  @default(false)
  productId   String   // Reference to ProductCatalog.id
  companyId   String   // For tenant isolation
  createdBy   String
  
  // NUEVO: Campos opcionales para multimedia
  description String?  @db.Text // Descripción opcional del media
  tags        String?  // Tags libres separados por espacios (ej: "#ficha_tecnica #foto_producto")
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  file        File           @relation(fields: [fileId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  product     ProductCatalog @relation(fields: [productId, companyId], references: [id, companyId], onDelete: Cascade, onUpdate: Cascade)
  creator     User           @relation(fields: [createdBy], references: [id], onDelete: Restrict, onUpdate: Cascade)
  
  // Only one favorite per product - handled at application level
  @@index([productId, companyId])
  @@index([fileId, productId, companyId])
  @@index([productId])
  @@index([fileId])
  @@index([createdBy])
  @@index([fileType])
}

model BulkProcessingRequest {
  id            String                @id @default(uuid())
  type          BulkProcessingType
  fileId        String?
  fileName      String
  status        BulkProcessingStatus  @default(PENDING)
  jobId         String?               @unique // Queue job ID, assigned when processing starts
  totalRows     Int?
  processedRows Int                   @default(0)
  successfulRows Int                  @default(0)
  failedRows    Int                   @default(0)
  rowLogs       Json?                 // Stores IBulkProcessingRowLog[] as JSON
  errorMessage  String?
  startedAt     DateTime?
  completedAt   DateTime?
  excelProcessingCompleted Boolean   @default(false) // True when Excel streaming phase is complete
  companyId     String
  requestedBy   String?
  metadata      Json?                 // Additional metadata including originalFileStatus
  createdAt     DateTime              @default(now())
  updatedAt     DateTime              @updatedAt

  // Relations
  company         Company               @relation(fields: [companyId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  requestedByUser User?                 @relation(fields: [requestedBy], references: [id], onDelete: SetNull, onUpdate: Cascade)
  file            File?                 @relation(fields: [fileId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  products        ProductCatalog[]      // Products created by this bulk request
  clientReminders ClientReminder[]      // Client reminders created by this bulk request

  // Composite indexes for performance
  @@index([companyId, status])
  @@index([companyId, type])
  @@index([companyId, requestedBy])
  @@index([companyId, createdAt])
}

// It is used to identify which phone numbers and which means should no longer send reminders, marketing, etc.
model ReminderNotificationOptOut {
  id           String                  @id @default(uuid())
  phone        String
  optOutType   ReminderNotificationOptOutType
  optOutMedium NotificationMedium
  reason       String?                 @db.Text
  createdAt    DateTime                @default(now())

  @@unique([phone, optOutType, optOutMedium])
  @@index([phone])
  @@index([optOutType])
  @@index([optOutMedium])
  @@index([createdAt])
}

model ClientReminderQueue {
  id                   String                @id @default(uuid())
  queueNumber          BigInt                // Sequential number per company (managed at application level) - used to be reminder_number - just for info
  name                 String                // Just for reference
  internalNameHash     String                // Same as name but normalized and hashed md5
  description          String?               // Just for reference details
  template             Json                  // Template to send to the bot endpoint when processing each reminder related to this queue
  targetMedium         NotificationMedium    // "App" the bot should send message
  notifyType           ReminderNotificationOptOutType // Event "type" to process
  callActions          String[]              // Array of call-to-action strings. [] = no actions needed

  // Should process queue? If false then reset status to STANDBY else check "STATUS_LOGIC". If status is COMPLETED DENY any change and leave it as false!
  active               Boolean               @default(false)
  
  // STATUS_LOGIC: COMPLETED if stopUntil is not null and is reached, else fallback to: IN_PROGRESS if now is within schedule else PENDING
  status               ReminderQueueStatus   @default(STANDBY)
  
  // Update every time the queue is checked by backend and status is IN_PROGRESS
  lastTimeChecked      DateTime?            // UTC is fine... it's just for info consumed by frontend (used to be lastTimeExecuted)
  companyId            String
  
  createdBy            String
  updatedBy            String?
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt

  // File tracking fields (same as ProductCatalog)
  sourceFileName       String?               // Name of the file this reminder used
  bulkRequestId        String?               // ID of the bulk processing request
  metadata             Json?                 // Additional metadata

  // Schedule config
  startDate            DateTime             // First day as Format: "yyyy-mm-dd" <-- should be exactly the date where the queue timezone is! Ignore time...
  endDate              DateTime             // Last day as Format: "yyyy-mm-dd" <-- should be exactly the date where the queue timezone is!. Ignore time... 
  interval             Int                  // It is any natural number. The minimum is 1 and the maximum is 1000.
  days                 String[]             // [] = any day | only take into account if frequency is WEEKLY
  startHour            String               // "14:00:00" 24-hour format (hh:mm:ss) in UTC
  endHour              String               // "04:00:00" 24-hour format (hh:mm:ss) in UTC
  maxCount             Int?                 // Maximum number of times a client reminder should be a candidate --> successCount < maxCount
  timezone             String               // Ej. America/Mexico_City
  frequency            ReminderFrequency
  stopUntil            DateTime?            // Format: "yyyy-mm-dd" <-- should be exactly the date where the queue timezone is! DO NOT Ignore time!!

  // Relations
  company              Company               @relation(fields: [companyId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  creator              User                  @relation("ClientReminderQueueCreatedBy", fields: [createdBy], references: [id], onDelete: Restrict, onUpdate: Cascade)
  updater              User?                 @relation("ClientReminderQueueUpdatedBy", fields: [updatedBy], references: [id], onDelete: Restrict, onUpdate: Cascade)
  reminders            ClientReminder[]
  scheduledClientReminderQueues ScheduledClientReminderQueues[]

  @@unique([companyId, queueNumber])
  @@unique([companyId, name])
  @@unique([companyId, internalNameHash])
  @@index([companyId])
  @@index([companyId, status])
  @@index([companyId, active])
}

model ClientReminder {
  /**
   * http_tries = ya no se utilizará...
   * async_http_status = ahora es lo mismo que (status: ReminderStatus)
  */

  id                   String                @id @default(uuid())
  clientPhone          String
  clientName           String
  targetMedium         NotificationMedium    // "App" the bot should send message --> this is just a copy of ClientReminderQueue for optimizations...
  notifyType           ReminderNotificationOptOutType // Event "type" to process --> this is just a copy of ClientReminderQueue for optimizations...

  // Updated each time after trying to contact bot
  sentLastTime         DateTime?             // UTC is fine... it's just for info consumed by frontend and backend only to check how many minutes from NOW()

  // Updated each time after trying to contact bot
  sentLastDay          DateTime?             // Format: "yyyy-mm-dd" <-- should be exactly the date where the queue timezone is!. Ignore time...

  // Updated to false ONCE every (new day in queue timezone!)
  receivedByBot        Boolean               @default(false) // This field is always false and is only modified by the bot through an endpoint provided at the application level. If it's true, it's no longer considered a record to be sent for the current queue on the present day.

  stopReminders        Boolean               @default(false) // TRUE if clientPhone exists in ReminderNotificationOptOut. This field should be set auto by a trigger before inserting row. If true, then it's no longer considered a record to send ever again!
  
  // Update to DONE if receivedByBot goes from false to true
  // Update to FAILED if receivedByBot goes from true to false via app logic
  // Update to IN_PROGRESS when backend is trying to contact bot and queue is withing schedule, else fallback to PENDING logic conditions...
  // Update ONCE to PENDING every new day in queue timezone if (queue.maxCount is null or successCount < queue.maxCount)
  status               ReminderStatus        @default(PENDING)

  // Updated ONCE to 0 every new day in queue timezone
  // +1 if lastHttpCode is null or not within range of any 2XX
  lastFailTimes        BigInt                @default(0) // Reset to 0 or 1 each new day. You can use for reference lastFailTime and NOW() at queue timezone!

  // Updated ONE to null every new day in queue timezone
  // Update every time lastFailTimes changes. If lastFailTimes is 0 do not update
  lastFailTime         DateTime?             // Full date with time and should be exactly the date where the queue timezone is!

  // Updated ONCE to null every new day in queue timezone
  // Update every time after contact bot
  lastHttpCode         Int?                  // Last http code provided by BOT when trying to contact him through the endpoint

  // Updated ONCE to null every new day in queue timezone
  // Update every time after contact bot
  lastHttpResponse     String?               // Last http response provided by BOT when trying to contact him through the endpoint

  successCount         Int                   @default(0) // +1 if receivedByBot goes from false to true via app logic. -1 otherwise... Min: 0 | Max: INF

  // File tracking fields (same as ProductCatalog)
  sourceFileName       String?               // Name of the file this reminder came from
  sourceRowNumber      Int?                  // Row number in the source file
  bulkRequestId        String?               // ID of the bulk processing request
  metadata             Json?                 // Additional metadata

  // Queue reference
  clientReminderQueueId String

  // Tenant isolation and audit
  companyId            String
  requestedBy          String
  updatedBy            String?
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt

  // Relations
  company              Company               @relation(fields: [companyId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  requester            User                  @relation("ClientReminderRequestedBy", fields: [requestedBy], references: [id], onDelete: Restrict, onUpdate: Cascade)
  updater              User?                 @relation("ClientReminderUpdatedBy", fields: [updatedBy], references: [id], onDelete: Restrict, onUpdate: Cascade)
  queue                ClientReminderQueue   @relation(fields: [clientReminderQueueId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  bulkRequest          BulkProcessingRequest? @relation(fields: [bulkRequestId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  @@unique([clientPhone, companyId, clientReminderQueueId])
  @@index([companyId])
  @@index([clientReminderQueueId])
  @@index([clientReminderQueueId, status])
  @@index([clientReminderQueueId, receivedByBot])
  @@index([companyId, status])
  @@index([companyId, stopReminders])
  @@index([clientPhone])
  @@index([bulkRequestId])
  @@index([clientPhone, targetMedium])
  @@index([clientPhone, targetMedium, notifyType])
  @@index([clientReminderQueueId, sentLastDay])
}

model ScheduledClientReminderQueues {
  id                    String                @id @default(uuid())
  createdAt             DateTime              @default(now())
  clientReminderQueueId String
  day                   String                // "yyyy-mm-dd" should be exactly the day where the queue timezone would be!. Ignore time...

  queue                ClientReminderQueue   @relation(fields: [clientReminderQueueId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@unique([clientReminderQueueId, day])
  @@index([clientReminderQueueId])
  @@index([day])
}
